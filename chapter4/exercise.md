# Chapter4 exercise

1. n500 = 1, n100 = 4, n50 = 1, n10 = 2 총 7개의 동전을 받는다.

2. 100, 50, 10이 500의 약수이고, 50, 10이 100의 약수이고, 10이 50의 약수이기 때문이다.

3. Coinchange가 리턴하는 동전 수 : n140 = 1, n50 = 1, n10 = 1 총 3개. 최소 동전 수 : n100 = 2, 총 2개.

4. 그림이라 생략

5. 우리 프로그래밍 과제.

6. (A,D), (D,F), (F,C), (D,B) (B,E), (F,G)

7. ?

8. A->D->E

9. 과제

10. 찾지 못함.

11. 필요없을듯?

12.
전체 원소 수를 x라고 했을 때, x 사이즈의 배열을 만들어서 0으로 초기화시킨 뒤, F의 원소인 S<sub>n</sub>을 순회하며 그 집합이 포함한 원소와 대응하는 배열의 원소를 1로 갱신한다. 하나라도 0이 있으면 set cover가 안 된 것이다.

```
set U = {1,2,3,...,n}
int x; // x = 전체 원소 수
int A[x]; // x 사이즈의 배열 선언
int n; // 부분집합의 수

for (i = 0; i < n; i++) {
  A[i] = 0; // 배열 초기화
}

for (i = 0; i < n; i++) {
  if int e∈(S<sub>i</sub>) {
    A[e-1] = 1; // 배열의 index는 0부터 시작하지만, U의 원소는 1부터 시작하기 
  }
}

for (i = 0; i < x; i++) {
  if (A[i] == 0) {
    break
    printf("Set cover failure");
  }
}

```
