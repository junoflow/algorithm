# Chapter4 exercise

1. n500 = 1, n100 = 4, n50 = 1, n10 = 2 총 7개의 동전을 받는다.

2. 100, 50, 10이 500의 약수이고, 50, 10이 100의 약수이고, 10이 50의 약수이기 때문이다.

3. Coinchange가 리턴하는 동전 수 : n140 = 1, n50 = 1, n10 = 1 총 3개. 최소 동전 수 : n100 = 2, 총 2개.

4. 그림이라 생략

5. 우리 프로그래밍 과제.

6. (A,D), (D,F), (F,C), (D,B) (B,E), (F,G)

7. ?

8. A->D->E

9. 과제

10. 찾지 못함.

11. 필요없을듯?

12.
전체 원소 수를 x라고 했을 때, x 사이즈의 배열을 만들어서 0으로 초기화시킨 뒤, F의 원소인 S<sub>n</sub>을 순회하며 그 집합이 포함한 원소와 대응하는 배열의 원소를 1로 갱신한다. 하나라도 0이 있으면 set cover가 안 된 것이다.

```
set U = {1,2,3,...,n}
int x; // x = 전체 원소 수
int A[x]; // x 사이즈의 배열 선언
int n; // 부분집합의 수

for (i = 0; i < n; i++) {
  A[i] = 0; // 배열 초기화
}

for (i = 0; i < n; i++) {
  if int e∈(S<sub>i</sub>) {
    A[e-1] = 1; // 배열의 index는 0부터 시작하지만, U의 원소는 1부터 시작하기 
  }
}

for (i = 0; i < x; i++) {
  if (A[i] == 0) {
    break
    printf("Set cover failure");
  }
}

```

13. 최적해 : S<sub>4</sub>, S<sub>5</sub>, 근사해 : S<sub>3</sub>, S<sub>2</sub>, S<sub>1</sub>

14. 최적해, 근사해 : S<sub>1</sub>, S<sub>5</sub>, S<sub>2</sub>, S<sub>3</sub>

15. 위에 꺼 풀고나니까 귀찮아짐 ^^

16. 
이른 종료 시간대로 정렬 : [0,2], [1,5], [1,6], [3,7], [6,8], [7,8], [5,9]
<p>
M1 [0,2] [3,7]
  
M2 [1,5] [6,8]
  
M3 [1,6] [7,8]

M4 [5,9]

최적해
M1 [0,2] [3,7] [7,8]

M2 [1,5] [5,9]

M3 [1,6] [6,8]

</p>

17.
