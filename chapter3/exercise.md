# Chapter 3 exercise

1. 한 번 분할할 때마다 n/2가 되므로 총 분할 횟수는 n/(2<sup>k</sup>)가 1이 될 때니까, k=log<sub>2</sub>n이다. 한 번 분할할 때마다 부분문제가 2개 생기므로, 전체 부분문제의 개수는 2<sup>k</sup>=2<sup>log<sub>2</sub>n</sup>=n

2. 한 번 분할할 때마다 n/2가 되므로 최대 분할 횟수 k=log<sub>2</sub>n이다. 부분문제의 수는 3<sup>log<sub>2</sub>n</sup>=n<sup>log<sub>2</sub>3</sup>개 이다.

3. 부분문제의 수는 a<sup>i</sup>이고, 이 때의 입력 크기는 n/(b<sup>i</sup>)이다.

4. 3을 바탕으로 생각해보면, 최대 분할 횟수 k=log<sub>b</sub>n이고, 이 때 부분문제의 수는 a<sup>log<sub>b</sub>n</sup>=n<sup>log<sub>b</sub>a</sup>개 이다.

5. 생략

6. iterative merge가 뭔지 모르겠당.

7. 우리 배운 partition 쓰면 될 듯.
굳이 적자면
```
Partition (A, left, right, p) {
  index i, j;
  key pitem;
  pitem = A[left] // pivot element를 가장 왼쪽 것으로.
  i = left; j = right+1;
  do {
    do i++;
    while (A[i] < pitem) // pitem보다 크면 멈춤
    do j--;
    while (A[j] > pitem) // pitem보다 작으면 멈춤
    if (i<j) exchange A[i] and A[j];
  } while (i<j)
  p = j;
  exchange A[left] and A[p]
}
```

8.
처음 표

0|1|2|3|4|5|6|7|8|9|10|11
---|---|---|---|---|---|---|---|---|---|---|---
8|3|11|9|12|2|6|15|18|10|7|14

A[2] <-> A[10]
  
0|1|2|3|4|5|6|7|8|9|10|11
---|---|---|---|---|---|---|---|---|---|---|---
8|3|7|9|12|2|6|15|18|10|11|14

A[3] <-> A[6]

0|1|2|3|4|5|6|7|8|9|10|11
---|---|---|---|---|---|---|---|---|---|---|---
8|3|7|6|12|2|9|15|18|10|11|14

A[4] <-> A[5]

0|1|2|3|4|5|6|7|8|9|10|11
---|---|---|---|---|---|---|---|---|---|---|---
8|3|7|6|2|12|9|15|18|10|11|14

A[0] <-> A[4] (A[left] <-> A[p]

0|1|2|3|4|5|6|7|8|9|10|11
---|---|---|---|---|---|---|---|---|---|---|---
2|3|7|6|8|12|9|15|18|10|11|14

9. 생략

10. 뭔가 문제가 이상한 듯?

11. Partition 대상의 크기가 1이 될 때까지 계속할 경우, 즉 small group엔 원소가 없고 Large group엔 n-1개의 원소가 속해 입력 크기가 1개만 줄어들게 되면 전체 비교 횟수가 n+(n-1)+...+2로 O(n<sup>2</sup>)이 되어버린다.

12. <p>O(n+3/4n+(3/4)<sup>2</sup>n+...+(3/4)<sup>i-1</sup>n+(3/4)<sup>i</sup>n)
    = O(n(1+3/4+(3/4)<sup>2</sup>+...+(3/4)<sup>i</sup>)
    1+3/4+(3/4)<sup>2</sup>+...+(3/4)<sup>i</sup>=∑<sub>n->∞</sub>(3/4)<sup>n</sup> </p>
